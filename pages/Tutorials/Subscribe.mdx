import { Subscribe } from "/components/Subscribe";

# Enabling Subscribers with XMTP

This tutorial will guide you on how to create a simple `Subscribe` button with consent that enables the user to subscribe to your messages or notifications.

<iframe
  src="/Frames/Subscribe"
  width="100%"
  height="162px"
  frameBorder="0"
  scrolling="no"
  allowFullScreen
></iframe>

## Considerations

Before diving into the code let's consider important aspects while integrating consent features. For example, before making an allow or block action you should synchronize the updated consent list in order to **prevent overwriting network** consent from another app. For more details head to these sections of our docs:

- [Understand user consent preferences](https://xmtp.org/docs/build/user-consent#understand-user-consent-preferences): Here are some of the ways user consent preferences are set
- [Use consent preferences to respect user intent](https://xmtp.org/docs/build/user-consent#use-consent-preferences-to-respect-user-intent): Your app should aim to handle consent preferences appropriately because they are an expression of user intent.
- [Synchronize user consent preferences](https://xmtp.org/docs/build/user-consent#synchronize-user-consent-preferences):All apps that use the user consent feature must adhere to the logic described in this section to keep the consent list on the network synchronized with local app user consent preferences, and vice versa.

## Quickstart

#### Import libraries

Import the necessary XMTP and Ethereum packages. These libraries enable you to create an XMTP client and interact with the Ethereum blockchain.

```jsx
import React, { useEffect, useState } from "react";
import { Client } from "@xmtp/xmtp-js";
import { ethers } from "ethers";
```

The receiver of the subscription (you), in this case is gong to be a random wallet generated by `ethers`, but you could send your own wallet as prop. This wallet is later going to

#### Subscribe with your Wallet

Your `connectWallet` function facilitates the connection to the user's Ethereum wallet.

```jsx
let wallet = await connectWallet();
let client = await Client.create(wallet, { env: env });
```

#### Consent State Management

This section delves into a crucial part of the subscription widget — managing the consent state of a subscriber. We'll explore how to get the subscriber's address, refresh the consent list, get the current consent state, and then update it based on user actions.

#### Refresh the Consent List

To ensure we're working with the most up-to-date information, we refresh the consent list.

```jsx
// Refresh the consent list to make sure your application is up-to-date with the
await client.contacts.refreshConsentList();
```

#### Retrieve the Current Consent State

After refreshing, we get the current consent state of the subscriber. Can be (`allowed`, `blocked`, or `unknown`)

```jsx
// Get the consent state of the subscriber
let state = client.contacts.consentState(client.address);
```

#### Update the Consent State

Based on the current state, we either allow or block the subscriber.

```jsx
// If the state is unknown or blocked, allow the subscriber
if (state == "unknown" || state == "denied") {
  await client.contacts.allow([senderAddress]);
}
```

- If the state is `unknown` or `blocked`, we change it to `allowed` using `client.contacts.allow([senderAddress])` and we call the `onSubscribe` function if it exists.
- If the state is `allowed`, we don't change the consent and we call the `onUnsubscribe` function if it exists.

**Callbacks**

The `onSubscribe` and `onUnsubscribe` functions are called when the consent state is updated. You can use these functions to update your local state or to send a message to your subscribers.

```jsx
<Subscribe
  onSubscribe={(address) => {
    //Update local db
    //or send a message to the subscriber
  }}
  onUnsubscribe={(address) => {
    //Update local db
    //or send a message to the subscriber
  }}
/>
```

## Caution ⚠️

**Always synchronize consent states:** Before updating consent preferences on the network, ensure you refresh the consent list with `await xmtp.contacts.refreshConsentList();`. Update the network's consent list only in these scenarios:

- **User Denies Contact:** Set to `denied` if a user blocks or unsubscribes.
- **User Allows Contact:** Set to `allowed` if a user subscribes or enables notifications.
- **Legacy Preferences:** Align the network with any existing local preferences.
- **User Response:** Set to `allowed` if the user has engaged in conversation.

Neglecting these guidelines can result in consent state conflicts and compromise user privacy.

## Conclusion

Consent has really evolved through the years. It started with email, then email marketing, and was the wild west until laws like GPDR stepped in. This is new chapter in the history of consent in a new era for privacy, portability, and ownership.

## Reference code

Copy paste the component into your project

```jsx
import React, { useState } from "react";
import { Client } from "@xmtp/xmtp-js";
import { ethers } from "ethers";

export function Subscribe({
  senderAddress,
  onSubscribe,
  onUnsubscribe,
  onError,
  env,
  label = "Subscribe with your wallet",
}) {
  // State for loading status
  const [loading, setLoading] = useState(false);
  // State for subscription status
  const [subscriptionStatus, setSubscriptionStatus] = useState(label);
  // State for consent log
  const [consentLog, setConsentLog] = useState("");
  // State for sender address

  const styles = {
    SubscribeButtonContainer: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      borderRadius: "5px",
      textAlign: "center",
      alignItems: "center",
    },
    SubscribeButton: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      padding: "10px 20px",
      borderRadius: "5px",
      marginBottom: "2px",
      textAlign: "left",
      cursor: "pointer",
      transition: "background-color 0.3s ease",
      fontWeight: "bold",
      color: "#333333",
      backgroundColor: "#ededed",
      border: "none",
      fontSize: "12px",
    },
  };

  const connectWallet = async () => {
    if (typeof window.ethereum !== "undefined") {
      try {
        await window.ethereum.request({ method: "eth_requestAccounts" });
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        return provider.getSigner();
      } catch (error) {
        console.error("User rejected request", error);
      }
    } else {
      console.error("Metamask not found");
    }
  };

  // Define the handleClick function
  const handleClick = async () => {
    try {
      // Set loading to true
      setLoading(true);
      // Get the subscriber
      let wallet = await connectWallet();
      let client = await Client.create(wallet, { env: env });

      // Refresh the consent list to make sure your application is up-to-date with the
      await client.contacts.refreshConsentList();

      // Get the consent state of the subscriber
      let state = client.contacts.consentState(senderAddress);

      // If the state is unknown or blocked, allow the subscriber
      if (state === "unknown" || state === "denied") {
        state = "allowed";
        await client.contacts.allow([senderAddress]);
        if (typeof onSubscribe === "function")
          onSubscribe(client.address, state);
      } else if (state === "allowed") {
        state = "denied";
        await client.contacts.deny([senderAddress]);
        // If the state is allowed, block the subscriber
        if (typeof onUnsubscribe === "function")
          onUnsubscribe(client.address, state);
      }

      //Print the whole list
      console.log(await client.contacts.refreshConsentList());
      console.log(await client.contacts.loadConsentList());

      // Set the subscription label
      setSubscriptionStatus("Consent State: " + state);

      // Set loading to false
      setLoading(false);
    } catch (error) {
      // If onError function exists, call it with the error
      if (typeof onError === "function") onError(error);
      // Log the error
      console.log(error);
    }
  };

  return (
    <div
      style={styles.SubscribeButtonContainer}
      className={`Subscribe ${loading ? "loading" : ""}`}
    >
      <small>Sender address: {senderAddress}</small>
      <button style={styles.SubscribeButton} onClick={handleClick}>
        {loading ? "Loading... " : subscriptionStatus}
      </button>
    </div>
  );
}
```

#### Example repo

- _You can find a complete example of this tutorial in our [xmtp-subscribe-portable-consent](https://github.com/fabriguespe/xmtp-subscribe-portable-consent)_
